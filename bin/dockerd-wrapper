#!/bin/bash
set -e

default_socket_group=docker

source $SNAP/bin/read-settings

workaround_lp1626019() {
    t=`egrep '/snap\.\w+_snap\.docker.dockerd_\w+/tmp ' /proc/self/mountinfo | cut -d ' ' -f 5`
    if [ -n "$t" ] && [ ! -e "$t" ]; then
        mkdir -p "$t"
        ln -s /sys "$t"/sys
    fi
}

workaround_lp1606510() {
    # ensure there's at least one member in the group.
    if [ $(getent group docker-snap | awk -F':' '{print $NF}') ]; then
        default_socket_group=docker-snap
    fi
}

generate_ssl_certificate() {
    ssl_crt="$cert_dir/domain.crt"
    ssl_key="$cert_dir/domain.key"

    if [ ! -f $ssl_crt ] || [ ! -f $ssl_key ]; then
        openssl req -newkey rsa:2048 -nodes -sha256 \
                    -subj "/CN=$domain_name" \
                    -x509 -days 365 -out $ssl_crt \
                    -keyout $ssl_key
    fi
}

yolo() {
	"$@" > /dev/null 2>&1 || :
}

force_umount() {
	yolo umount    "$@"
	yolo umount -f "$@"
	yolo umount -l "$@"
}

dir="$(mktemp -d)"
trap "force_umount --no-mtab '$dir'; rm -rf '$dir'" EXIT
# try mounting a few FS types to force the kernel to try loading modules
for t in aufs overlay zfs; do
	yolo mount --no-mtab -t "$t" /dev/null "$dir"
	force_umount --no-mtab "$dir"
done
# inside our snap, we can't "modprobe" for whatever reason (probably no access to the .ko files)
# so this forces the kernel itself to "modprobe" for these filesystems so that the modules we need are available to Docker
rm -rf "$dir"
trap - EXIT

# use SNAP_DATA for most "data" bits
mkdir -p \
	"$SNAP_DATA/run" \
	"$SNAP_DATA/run/docker" \
	"$SNAP_COMMON/var-lib-docker" \
	"$registry_cert_dir" \
	"$cert_dir"
set -- \
	--debug \
	--log-level=debug \
	\
	--exec-root="$SNAP_DATA/run/docker" \
	--graph="$SNAP_COMMON/var-lib-docker" \
	--pidfile="$SNAP_DATA/run/docker.pid" \
	--registry-certificate-dir="$registry_cert_dir" \
	\
	"$@"

workaround_lp1626019

workaround_lp1606510

generate_ssl_certificate

exec dockerd -G $default_socket_group "$@"
